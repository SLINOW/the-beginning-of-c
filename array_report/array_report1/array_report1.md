# array_report1.c

## 1.アルゴリズム
for文だけを用いる方法では,数列を逆順に出力するのは難しい.
そのため,漸化式を1から7まで計算し,その結果を配列に一旦格納した上で,7番目から3番目の値をfor文を用いて降順で出力する.

## 2.ソースコードの説明
作成したソースコードの一部は以下の通りである.
```c
float array[7];
int i;

/* x1 の初期化 */
array[0] = 300;
/* x2 〜 x7 の計算 */
for (i = 1; i <= 6; i++) {
  array[i] = array[i - 1] / 2;
}

/* x7 〜 x3 の出力 */
for (i = 6; i >= 2; i--) {
  printf("x%d = %f\n", i + 1, array[i]);
}
```
アルゴリズムの説明で述べたように,漸化式の値を一時的に保存しておく配列を用意する.

配列は0番目から始まることに注意して,配列の0番目に数列の1番目である300を代入しておく.

配列の1番目から6番目(数列では2番目から7番目)は,漸化式に従って1つ前の値を2で割った値を配列に格納していく.

配列の6番目(数列の7番目)まで計算が終わったら,for文を用いて配列の6番目から2番目(数列では7番目から3番目)までの値を降順で出力している.

## 3.考察
最後に配列の値を出力する部分において,
```c
for (i = 6; i >= 2; i--)
```
という指定をしている.
for文は,
```c
for (変数の初期化; 継続条件; 変数の書き換え)
```
という指定方法であることを考えれば,
継続条件として`i > 2`としてしまうと`i = 3`までしか出力処理が行われず,配列の3番目(数列の4番目)の値までしか出力されなくなってしまうことに注意が必要である.

また,今回は漸化式の計算結果が小数になりうるので,計算過程や配列ではfloat型を用いる必要がある.

配列の番号(インデックス)と数列の番号が一致していないと混乱を招く恐れがあるので,配列の番号(インデックス)と数列の番号を一致させて書くことも可能である.
例えば,以下のようなコードになる.
```c
float array[8]; /* 0番目は使用しない. 0番目を含め,1番目から7番目の合計8個の数を保存する必要がある */
int i;

/* x1の初期化 */
array[1] = 300;
/* x2 〜 x7 を順に計算 */
for (i = 2; i <= 7; i++) {
  array[i] = array[i - 1] / 2;
}

/* x7 〜 x3 を降順で出力 */
for (i = 7; i >= 3; i--) {
  printf("x%d = %f\n", i, array[i]);
}
```
こちらの方がインデックスのずれを考えなくて良いため理解しやすいかもしれない.