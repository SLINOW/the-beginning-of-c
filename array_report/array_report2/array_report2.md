# array_report2.c

## 1.アルゴリズム
成績データを配列に格納しておき,for文を用いてその配列の要素を順に見ていく.
要素が60点未満であったら,配列のインデックスに1足した数を出力する.(これは,配列のインデックスと受験者番号が1ずれていることに起因する.)

## 2.ソースコードの説明
作成したソースコードの一部は以下の通りである.
```c
/* 成績データ */
int score[] = {10, 40, 90, 70, 50, 80, 20, 90, 60, 50, 70, 60, 0};
int i;

for (i = 0; i < 13; i++) {
  /* 60点未満の生徒の番号を出力する (indexが1ずれていることに注意する) */
  if (score[i] < 60) {
    printf("%d ", i + 1);
  }
}
printf("\n");
```
アルゴリズムの説明で述べたように,成績データを保存する配列を用意し,与えられた成績データで初期化しておく.

for文を用いて13回ループを回し,全てのデータを探索する.
もし,データの要素が60未満であったら,そのインデックスに1を足して得られる受験者番号を出力する.

## 3.考察
今回作成したプログラムにおいては,60点未満の受験者番号をすぐに出力するという方法をとっている.
一方で,この受験者番号を保存して他の処理を行いたい場合も出てくる可能性がある.
このような場合に対応するコードの例を以下に示す.
```c
/* 成績データ */
int score[] = {10, 40, 90, 70, 50, 80, 20, 90, 60, 50, 70, 60, 0};
/* 条件に合致する受験者番号. 大きさは十分大きくしておく. */
int candidate_number[100];
/* index は candidate_number のどの位置に値を入れるかを保存しておく変数 */
int i, index = 0;

for (i = 0; i < 13; i++) {
  /* 60点未満の生徒の番号を配列に格納する (indexが1ずれていることに注意する) */
  if (score[i] < 60) {
    candidate_number[index] = i + 1;
    index++;
  }
}

/* 最後の探索で, index は1足された状態(最後の要素の次)なので,個数は (index - 1) 個になることに注意 */
for (i = 0; i < index - 1; i++) {
  printf("%d ", candidate_number[i]);
}
printf("\n");
```
提出したソースコードとの違いを説明する.

60点未満であった場合,その点数をとった受験者の受験番号を配列に格納し保存しておく.
その際に,配列のどこに格納するかを記憶しておく必要があるため,記憶用の変数を用意し更新する.

最後に,受験番号を格納した配列の全ての要素を出力する.